#define LEFT_MOTOR OUT_A
#define RIGHT_MOTOR OUT_C
#define MOVE_MOTORS OUT_AC
#define COLOR_MOTOR OUT_B

#define PLANSZA_ROZMIAR 5

int debugIndex = 0;
void debug(string text)
{
     ClearLine( LCD_LINE1 - debugIndex);
     TextOut(0, LCD_LINE1 - debugIndex, text, 0);
     debugIndex+=8;
     debugIndex %= LCD_LINE1;
}

#include "stos.nxc"
STOS(int)
#include "kolejka.nxc"
QUEUE(int)
#include "vector.nxc"
VECTOR(int)
#include "heap.nxc"

void blad(string tekst1, string tekst2="", string tekst3="")
{
     PlaySound(SOUND_DOUBLE_BEEP);
     PlaySound(SOUND_DOUBLE_BEEP);
     debug(tekst1);
     debug(tekst2);
     debug(tekst3);
     while(true);
}

enum WiezaTyp
{
    WIEZA_BRAK,
    WIEZA_NIEBIESKA,
    WIEZA_BIALA
};

#define NORTH 0
#define SOUTH 1
#define EAST 2
#define WEST 3

enum RelativeDirection
{
    FRONT = 0,
    LEFT,
    RIGHT,
    BACK
};

struct Position
{
   int x;
   int y;
};

bool position_equals(const Position a, const Position b)
{
    return (a.x == b.x && a.y == b.y);
}
                                  // global orientation  rel of which to calc
int relativeAsGlobal[4][4] =
{
// north
 {NORTH,  WEST, EAST, SOUTH},
 // south
 {SOUTH,  EAST, WEST, NORTH},
 // east
 {EAST,  NORTH, SOUTH, WEST},
// west
 {WEST,  SOUTH, NORTH, EAST},
};

bool position_isValid(Position& pos)
{
    return !(pos.x < 0 || pos.x >= PLANSZA_ROZMIAR || pos.y < 0 || pos.y >= PLANSZA_ROZMIAR);
}

// polnoc-polodnie - Y - druga wspolrzedna
// wschod zachod - X - pierwsza wspolrzedna
Position position_getNeighbour(Position& pos, int globalDirection)
{
    Position ret;
    switch(globalDirection)
    {
       case NORTH:
          ret.x = pos.x;
          ret.y = pos.y - 1;
       break;
       case SOUTH:
          ret.x = pos.x;
          ret.y = pos.y + 1;
       break;
       case EAST:
          ret.x = pos.x + 1;
          ret.y = pos.y;
       break;
       case WEST:
          ret.x = pos.x - 1;
          ret.y = pos.y;
       break;
    }
}



struct Pole
{
    bool znane;
    WiezaTyp wieza;
};

bool pole_canEnter(const Pole  pole)
{
   return !pole.znane || pole.wieza == WIEZA_BRAK;
}

void getNeighbours(Position& pos, int orientation, Position& outNeighbours[])
{
    for (int i = 0; i < 4; ++i)
    {
      outNeighbours[i] = position_getNeighbour(pos, relativeAsGlobal[orientation][i]);
    }
}
Pole plansza[PLANSZA_ROZMIAR][PLANSZA_ROZMIAR];

int calcHeurystyka(Position pos, int powrot)
{
    if (powrot)
       return 8 - pos.x - pos.y;
    return pos.x + pos.y;
}

int kosztRuchu[] = {1, 2, 2, 3};

int calcKoszt(int kierunekWzgledny)
{
    return kosztRuchu[kierunekWzgledny];
}

bool isGoal(Position pos, int powrot)
{
    if (powrot)
        return pos.x == 4 && pos.y == 4;
    return pos.x == 0 && pos.y == 0;
}

Position getGoal(int powrot)
{
     Position p;
    if (powrot)
    {
      p.x = p.y = 4;
    }
    else
      p.x = p.y = 0;

    return p;
}

struct AstarNode
{
   Position pos;
   int orientation;
   int g;
   int f;
};

bool minNode(AstarNode a, AstarNode b)
{
    return a.f < b.f || (a.f == b.f && a.g < b.g);
}

VECTOR(AstarNode)
HEAP(AstarNode, minNode)

struct AstarField
{
   bool visited;
   Position fromWhere;
   int moveOrientation;
};

void search(Position& pos, int orientation, bool czyPowrot, Pole grid[][], Stos_int outKierunkiRuchu)
{
    AstarField fields[PLANSZA_ROZMIAR][PLANSZA_ROZMIAR];
    for(int i = 0; i < PLANSZA_ROZMIAR; ++i)
        for(int j = 0; j < PLANSZA_ROZMIAR; ++j)
        {
            fields[i][j].visited = false;
        }

    bool found = false;
    bool resign = false;
    
    Vector_AstarNode open;
    vector_AstarNode_init(open, PLANSZA_ROZMIAR*PLANSZA_ROZMIAR);
    
    AstarNode current;
    current.pos = pos;
    current.orientation = orientation;
    current.g = 0;
    current.f = current.g + calcHeurystyka(pos, czyPowrot);
    
    heap_AstarNode_minNode_insert(open, current);
    
    AstarNode next;

    while (!found && !resign)
    {
        if (open.size == 0)
        {
            resign = 1;
            return;
        }
        else
        {
            current = heap_AstarNode_minNode_removeMin(open);

            if (isGoal(current.pos, czyPowrot))
            {
                found = 1;
            }
            else
            {
                for (int i = 0; i < 4; ++i)
                {
                    next.orientation = relativeAsGlobal[current.orientation][i];
                    next.pos = position_getNeighbour(pos, next.orientation);
                    if (position_isValid(next.pos))
                    {
                        if (!fields[next.pos.x][next.pos.y].visited && pole_canEnter(plansza[next.pos.x][next.pos.y]))
                        {
                            next.g = current.g + calcKoszt(i);
                            next.f = current.g + calcHeurystyka(pos, czyPowrot);
                            heap_AstarNode_minNode_insert(open, next);
                            fields[next.pos.x][next.pos.y].visited = true;
                            fields[next.pos.x][next.pos.y].fromWhere = current.pos;
                            fields[next.pos.x][next.pos.y].moveOrientation = i;
                        }
                    }
                }
            }
        }
    }

    Position goal = getGoal(czyPowrot);
    AstarField field;

    while (!position_equals(goal, pos))
    {
        field = fields[next.pos.x][next.pos.y];
        stos_int_push(outKierunkiRuchu, field.moveOrientation);
        goal = field.fromWhere;
    }
}

enum Cmds
{
    CMD_JEDZ_PRZOD = 1,
    CMD_OBROT_LEWO,
    CMD_OBROT_PRAWO,
    CMD_ZAKONCZ_PRZEJAZD,
    CMD_WYMYSL_RUCHY
};

Queue_int polecenia;

void wymyslRuchy()
{
    queue_int_makeEmpty(polecenia);
    Stos_int kierunkiRuchu;
    stos_int_init(kierunkiRuchu, 100);

    
    queue_int_put(polecenia, CMD_ZAKONCZ_PRZEJAZD);
}

// ruch o jedno pole
void jedzPrzod()
{
     OnRevSync(MOVE_MOTORS, 50, 0);
     Wait(2000);
     Off(MOVE_MOTORS);
}

void obrotLewo()
{
}

void obrotPrawo()
{
}

void zakonczPrzejazd()
{
     PlaySound(SOUND_DOUBLE_BEEP);
     abort();
}

task main()
{
  queue_int_init(polecenia, 100);
  while(true)
  {
    wymyslRuchy();
    while(!queue_int_empty(polecenia))
    {
       Cmds polecenie = queue_int_front(polecenia);
       queue_int_pop(polecenia);
       switch(polecenie)
       {
           case CMD_JEDZ_PRZOD: jedzPrzod(); break;
           case CMD_OBROT_LEWO: obrotLewo(); break;
           case CMD_OBROT_PRAWO: obrotPrawo(); break;
           case CMD_ZAKONCZ_PRZEJAZD: zakonczPrzejazd(); break;
           case CMD_WYMYSL_RUCHY: wymyslRuchy();  break;
           default:
                  blad("NIEPRAWIDLOWA OBSLUGA KOMENDY");

       }
     }

   }
}
